import ij.*;import ij.plugin.filter.PlugInFilter;import ij.process.*;import java.awt.*;/** This sample ImageJ plug-in filter inverts 8-bit images.A few things to note:	1) Filter plug-ins must implement the PlugInFilter interface.	2) Plug-ins located in the "plug-in" folder must not use	the package statement;	3) Plug-ins residing in the "plugins" folder and with at	least one underscore in their name will be automatically	installed in the PlugIns menu.	4) Plug-ins can be installed in other menus be editing	the ij.properties file.	5) You must edit ij.properties to get you plug-in to appear	in the Help->About PlugIns sub-menu.	6) The class name and file name must be the same.	7) This filter works with ROIs, including non-rectangular ROIs.	5) It will be called repeatedly to process all the slices in a stack.	6) This plug-in can't be named "Invert_" because this would	conflict with the built-in command of the same name.*/public class Hocr_Plugin implements PlugInFilter {	// initialize class	static	{		System.loadLibrary("hocr_java");		// to specify full path:		//   System.load("c:/path/to/dll/hocr-java.dll");			}	public int setup(String arg, ImagePlus imp) {		if (arg.equals("about"))			{showAbout(); return DONE;}		return 	DOES_8G + 		// 8-bit grayscale images.				DOES_8C + 		// 8-bit indexed color images.				DOES_RGB + 		// RGB images.				DOES_STACKS + 	// Set this flag if the filter wants its run() 								// method to be called for all the slices in a stack.				SUPPORTS_MASKING; // for non-rectangular ROIs, ImageJ shoud restore								// that part of the image that's inside the bounding								// rectangle but outside of the ROI.	}	public static native String doOcr_Params(		byte[] pixels,		int height,		int width,		int rowstride, //0=calculate using n_channels,width		int n_channels, // 1,3		int brightness, //0=default		int command, //0=default  		int start_x,		int start_y    	);	public void run(ImageProcessor ip) {		if (ip instanceof ColorProcessor)		{			ij.text.TextWindow text = new ij.text.TextWindow("OCR Result", "ip.getClass() == ColorProcessor", 300,300);			return;		}				byte[] pixels = (byte[])ip.getPixels();		int width = ip.getWidth();		Rectangle r = ip.getRoi();		/*				int offset, i;		for (int y=r.y; y<(r.y+r.height); y++) {			offset = y*width;			for (int x=r.x; x<(r.x+r.width); x++) {				i = offset + x;				pixels[i] = (byte)(255-pixels[i]);			}		}		*/				String ocr = 	doOcr_Params(			pixels,			r.height, //ip.getHeight(),			r.width, //ip.getWidth(),			ip.getWidth(), //0=calculate using n_channels,width			1, // 1,3			100, //0=default			0, //0=default			r.x,  // start_x			r.y   // start_y		);		ij.text.TextWindow text = new ij.text.TextWindow("OCR Result", ocr, 300,300);		//text.show();				//new ImagePlus("Result from Tal-Filter", new_ip).show();	}	/*	public void run(ImageProcessor ip) {		byte[] pixels = (byte[])ip.getPixels();		int width = ip.getWidth();		Rectangle r = ip.getRoi();				ImageProcessor new_ip = new ColorProcessor(r.width, r.height);		int[] new_pixels = (int[])new_ip.getPixels();				int offset, i;		for (int y=r.y; y<(r.y+r.height); y++) {			offset = y*width;			for (int x=r.x; x<(r.x+r.width); x++) {				i = offset + x;				//pixels[i] = (byte)(255-pixels[i]);				new_pixels[y*r.width+x] = (byte)(255-pixels[i]);			}		}		new ImagePlus("Result from Tal-Filter", new_ip).show();		//Use ComponentOrientation property of almost all Swing components. Here is an example with JTextArea and Hebrew:		//  Locale hebrew = new Locale("he", "IL");		//  JTextArea area = new JTextArea();		//  area.setComponentOrientation(ComponentOrientation.getOrientation(hebrew));		ij.text.TextWindow text = new ij.text.TextWindow("title",           "? ?"           //"data"           ,        300,300);		//text.show();    java.util.Locale hebrew = new java.util.Locale("he", "IL");    text.getTextPanel().setComponentOrientation(ComponentOrientation.getOrientation(hebrew));	}	*/		void showAbout() {		IJ.showMessage("About Inverter_...",			"This plug-in filter does Hebrew OCR to 8-bit and RGB images,\n" +			"using the HOCR library.\n" +			"See http://hocr.berlios.de/ \n" +			""		);	}}
